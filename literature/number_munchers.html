<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- base href="http://www.cs.cmu.edu/~410/p1/proj1.html" --></head><body bgcolor="white"><div style="background:#fff;border:1px solid #999;margin:-1px -1px 0;padding:0;"><div style="background:#ddd;border:1px solid #999;color:#000;font:13px arial,sans-serif;font-weight:normal;margin:12px;padding:8px;text-align:left">This is Google's cache of <a href="http://www.cs.cmu.edu/%7E410/p1/proj1.html" style="text-decoration: underline; color: rgb(0, 0, 204);">http://www.cs.cmu.edu/~410/p1/proj1.html</a>. It is a snapshot of the page as it appeared on 5 Jan 2012 03:14:34 GMT. The <a href="http://www.cs.cmu.edu/%7E410/p1/proj1.html" style="text-decoration: underline; color: rgb(0, 0, 204);">current page</a> could have changed in the meantime. <a href="http://www.google.com/intl/en/help/features_list.html#cached" style="text-decoration: underline; color: rgb(0, 0, 204);">Learn more</a><br><br><div style="float:right"><a href="http://webcache.googleusercontent.com/search?q=cache:UBgX2FULaXYJ:www.cs.cmu.edu/%7E410/p1/proj1.html&amp;hl=en&amp;client=ubuntu&amp;strip=1" style="text-decoration: underline; color: rgb(0, 0, 204);">Text-only version</a></div>
<div>&nbsp;</div></div></div><div style="position:relative">
<!-- BEGIN COMMENTED-OUT SECTION -->

<!-- END COMMENTED-OUT SECTION -->

<!-- ========================================= -->
<!-- Page title (begin it with "15-410") ===== -->
<!-- ========================================= -->







<title>15-410 Project 1: Number Munchers</title>


<table height="100%" width="100%">

<tbody><tr><td valign="top" width="132">
<table height="100%" width="132" bgcolor="#cccccc">
<tbody><tr><td height="140"><center><font size="-1"><b>Carnegie Mellon</b></font><br>
<img alt="SCS logo" src="number_munchers_files/scslogo.gif"><br>
<font size="-1"><b>Computer Science Department</b></font></center></td></tr>
<tr><td height="30"><a href="http://www.cs.cmu.edu/%7E410"><img alt="home" src="number_munchers_files/home.gif" border="0"></a></td></tr>
<tr><td height="30"><a href="http://www.cs.cmu.edu/%7E410/syllabus.html"><img alt="syllabus" src="number_munchers_files/syllabus.gif" border="0"></a></td></tr>
<tr><td height="30"><a href="http://www.cs.cmu.edu/%7E410/staff.html"><img alt="staff" src="number_munchers_files/staff.gif" border="0"></a></td></tr>
<tr><td height="30"><a href="http://www.cs.cmu.edu/%7E410/schedule.html"><img alt="schedule" src="number_munchers_files/schedule.gif" border="0"></a></td></tr>
<tr><td height="30"><a href="http://www.cs.cmu.edu/%7E410/lecture.html"><img alt="lecture" src="number_munchers_files/lecture.gif" border="0"></a></td></tr>
<tr><td height="30"><a href="http://www.cs.cmu.edu/%7E410/projects.html"><img alt="projects" src="number_munchers_files/projects.gif" border="0"></a></td></tr>
<tr><td height="30"><a href="http://www.cs.cmu.edu/%7E410/homeworks.html"><img alt="homeworks" src="number_munchers_files/homeworks.gif" border="0"></a></td></tr>
<tr><td>&nbsp;</td></tr></tbody></table>

</td>

<td width="10">&nbsp;</td>

<td height="100%" valign="top">
<br>

<h1 align="CENTER">15-410 Project 1: Number Munchers</h1>
<hr>
<!-- Body goes here. -->
 

<!-- ========================================= -->
<!-- Content Begins ========================== -->
<!-- ========================================= -->

    <h3>Table of Contents</h3>
    <ul>
      <li><a href="#overview">Project Overview</a></li>
      <li><a href="#goals">Goals</a></li>
      <li><a href="#disclaimer">Technical Disclaimer</a></li>
      <li><a href="#includes">Header Files</a></li>
      <li><a href="#dates">Important Dates</a></li>
      <li><b><a href="#welcome">Welcome to x86 Kernel Programming</a></b></li>
      <li><a href="#worst">Kernel Programming: Always Assuming the Worst</a></li>
      <li><a href="#privileges">Privilege Levels</a></li>
      <li><a href="#segmentation">Segmentation</a></li>
      <li><a href="#comdev">Communicating with Devices</a></li>
      <li><a href="#interrupts">Hardware Interrupts</a></li>
      <li><a href="#exceptions">Traps and Exceptions</a></li>
      <li><a href="#confint">Configuring Interrupts</a></li>
      <li><a href="#writingint">Writing an Interrupt Handler</a></li>
      <li><b><a href="#consolespec">Console Device Driver Specification</a></b></li>
      <li><a href="#writingchar">Writing a Character to the Console</a></li>
      <li><a href="#commcrtc">Communicating with the CRTC</a></li>
      <li><a href="#consoleint">Console Device Driver Interface</a></li>
      <li><b><a href="#timerspec">Timer Device Driver Specification</a></b></li>
      <li><a href="#conftimer">Configuring the Timer</a></li>
      <li><a href="#timerint">Timer Device Driver Interface</a></li>
  
      <li><b><a href="#keyspec">Keyboard Device Driver Specification</a></b></li>
      <li><a href="#interactkey">Interacting with the Keyboard</a></li>
      <li><a href="#keyint">Keyboard Device Driver Interface</a></li>
      <li><a href="#FPU">Floating-Point Unit (FPU)</a></li>
      <li><b><a href="#defkernel">Skeleton Kernel</a></b></li>
      <li><a href="#cfunctions">Provided C Functions</a></li>
      <li><b><a href="#testing">Testing</a></b></li>
      <li><a href="#tying">Tying it All Together</a></li>
      <li><a href="#game">Number Munchers</a></li>
      <li><a href="#doxygen">Documenting</a></li>
      <li><a href="#notes">Other Important Notes</a></li>
      <li><b><a href="#simics">Testing and Debugging with Simics</a></b></li>
      <li><a href="#getsimics">Getting Started with Simics</a></li>
      <li><a href="#biosboot">The BIOS and Bootloader</a></li>
      <li><a href="#triplefault">A Note on "Triple Faults"</a></li>
      <li><a href="#dualimage">Grading Makefile and Dual Images</a></li>
      <li><a href="#handin">Hand-in Instructions</a></li>
      <li><a href="#starting">Where do I start???</a></li>
      <li><a href="#licenses">Software license notice</a></li>
    </ul>

    <a name="overview"><h3>Project Overview</h3></a>
In this introductory project you will be writing three device drivers.
These three device drivers will constitute a library which will be
used to construct single-task "kernel applications".  You will write a
small game application to run on top of your library.  In addition, we
will provide you with a basic application that will test some aspects
of your device-driver library.  <p>

The first is the console device driver. The console device driver is
responsible for printing characters on the screen.  Without it, it
would be rather difficult later in the semester to obtain feedback as
to what is going on in your operating system or user applications.</p><p>

The second device driver you will write is the keyboard device
driver. Whenever the user presses a key, the keyboard device driver
needs to find out what key it is, whether it was pushed or released,
and then make that information available to the operating system. An
important aspect of the keyboard device driver is that it is interrupt
driven. We will take a closer look at what this means later.</p><p>

The third "device driver" is the timer handler. While we do not often
think of the on board PC timer as a device, it generates interrupts
just like the keyboard. The timer is a critical device that will be
used later in context switching between processes.</p><p>

It is not possible to test these device drivers on their own. In order
to develop and test them, you will be provided with a skeleton
kernel. The kernel performs some very basic machine initialization
such as transitioning to protected mode. Once this initialization is
complete, it transfers control to the application's
<code>kernel_main()</code> function, which will initialize your device
drivers and begin executing application-specific code.  There is no
virtual memory and no file system.</p><p>

Once you have implemented the three device drivers, you will use the
three of them to implement a game called 
Number Munchers
A detailed
explanation of the desired behavior is presented later in this
handout.</p><p>

<a name="goals"></a></p><h3><a name="goals">Goals</a></h3>
Despite the fact that this is a small project relative to the kernel,
it is important to pay attention to the key concepts in Project 1. The
ideas taught here will provide the foundation for the next three
projects. In particular, we would like you to be comfortable with:

<ol>
<li><p>Writing clean code in C. Many people like the C programming
language because it gives the programmer a lot of freedom (pointers,
casting, etc).  It is very easy to hang yourself with this rope.
Developing (and sticking with) a consistent system of variable
definitions, commenting, and separation of functionality is
essential.</p>

<p>People have asked about using C++ in this class.  This is probably
much harder than you think, since you would need to begin by
implementing your own thread-safe (or, at least, interrupt-aware)
versions of <tt>new</tt> and <tt>delete</tt>.  In addition, you would
probably find yourself implementing other pieces of C++ runtime code;
this could turn into quite a hobby.
We strongly recommend that you do this
program in C as a way of re-familiarizing yourself with the language
you'll be using for the remainder of the course.
</p>
</li>

<li>Writing pseudocode or code outlines.  For systems programming, it
is very important to think out crucial data structures and algorithms
ahead of time since they become important primitives for the rest of
the system.</li>

<li>Commenting.  Though you will not be working with a partner for the
first project, you will be on all subsequent projects.  It is
important to include comments so someone else looking at or
maintaining your code can quickly understand what your code is doing
without having to look at its internals.  We will be using a system
called <a href="#doxygen">doxygen</a> that creates documents similar
to javadoc.

</li><li>Debugging/testing operating system code. We will be using Simics,
an instruction set simulator with a built-in debugger to debug and
test; it is similar to gdb, but has some important differences and
will take some getting used to.</li>

<li>Using common development tools (gcc, ld).</li>

<li>Understanding device drivers: their role in the system, and their
requirements.</li>

<li>Communicating with the TAs using various channels of communication
(zephyr, bulletin board, <img src="number_munchers_files/staff-410.gif" alt="staff-410 at the CS domain">, Q&amp;A archive, course web page,
office hours).</li>
</ol>

In addition to these primary goals, mundane details such as software
installation (e.g., getting AFS installed on a personal Linux machine)
should be taken care of by the end of Project 1.

<a name="disclaimer"><h3>Technology Disclaimer</h3></a> Because of the
availability, low cost, and widespread use of the x86 architecture, it
was chosen as the platform for this sequence of projects. As its
creator, Intel Corporation has provided much of the documentation used
in the development of these projects. In its literature, Intel uses
and defines terms like interrupt, fault, etc. On top of this the x86
architecture will be the only platform used in these projects.<p> The
goal of this project set is certainly not to teach the idiosyncrasies
of the x86 architecture (or Intel's documentation). That said, it will
be necessary to become accustomed to the x86 way of doing things, and
the Intel nomenclature, for the purposes of completing this project
set. Just keep in mind that the x86 way of doing things is not the
only way of doing things. It is the price to be paid for learning the
principles of operating systems on a real world system instead of a
simulated architecture.

<a name="includes"></a></p><h3><a name="includes">Header Files</a></h3> In many places within
this document, we will refer to <tt>#define</tt>s in several .h files.
The directories mentioned will be created when you untar the project
tarball.

<a name="dates"><h3>Important Dates</h3></a>
<dl>
<dt><b>Friday, September 9</b> 
</dt><dd>Project 1 assigned.
</dd><dt><b>Wednesday, September 14</b> 
</dt><dd>You should at least: be familiar with using Simics, have console output
working, and have started on the keyboard and timer interrupts.
</dd><dt><b>Monday, September 19</b> 
</dt><dd>Project 1 is due at 11:59pm.<br>
</dd></dl>

<a name="welcome"><h2>Welcome to x86 Kernel Programming</h2></a> These
projects will be a new experience for many of you because they are
special in two ways. The first is that, as kernel programmers, you are
subject to a number of constraints that do not show up in user-level
programming. The second is that you will need to look down at the
hardware you are running on and manipulate device registers/processor
data structures to get your kernel to work. Because this is new for
many of you, the following section is devoted to saying a few things
about kernel programming, and then summarizing some of the important
features of the x86 architecture which you will need to know.

<a name="worst"><h3>Kernel Programming: Always Assuming the
Worst</h3></a> Programming in the kernel is quite different from
writing user level applications. As has been emphasized in class,
safety is a priority in kernel code - that is, checking pointers
passed to you by user code before you dereference them, testing all
possible cases to ensure there are no infinite loops, etc. Kernels
need to be as absolutely bulletproof as possible. For example, the
following line will happily execute as part of your kernel:<p>

<tt>*(unsigned int*)0x0 = 0x1badd00d;</tt></p><p>

Wild pointer accesses are much more dangerous in kernel mode because
valuable kernel data structures are not protected by the user
mode/kernel mode protection schemes of the processor (discussed here
shortly).  Dereferencing and writing to a bad pointer like this within
the kernel can overwrite crucial kernel data, or reboot the (simulated)
machine, or worse!</p><p>

<a name="privileges"></a></p><h3><a name="privileges">Privilege Levels</a></h3> The x86
architecture uses privilege levels to make defending the kernel
against wild user processes easier. There are four privilege levels
ranging from zero to three, with zero being the most privileged and
three being the least. At any given time, the processor is "executing"
in one of these four privilege levels. As you might have already
guessed, your kernel code will execute at privilege level zero, while
user code should execute at privilege level three. We will not be
using privilege levels one or two in these projects. We will refer to
privilege levels zero and three as PL0 and PL3 respectively. Because
of the way privilege levels are explained in section 4.5 of
intel-sys.pdf, privilege levels are often called "rings" (as in ring
zero or ring three), though we will try to avoid that notation in
these projects.<p>

The processor checks the privilege level (PL) in a number of
circumstances, such as when an attempt is made to execute a privileged
instruction. These are instructions that modify control registers or
change how the processor is running (a list of these instructions can
be found in section 4.9 of intel-sys.pdf). These are instructions we
would want only the kernel to be able to execute, so they are only
allowed while the processor is running in more privileged levels (such
as PL0). If you try to execute such instructions at other privilege
levels, a fault occurs.

<!-- Fun thought experiment: If privileged
instructions cause a fault, how does one then change privilege levels? -->

<a name="segmentation"></a></p><h3><a name="segmentation">Segmentation</a></h3>
While we will try to avoid using segmentation as much as possible
for the duration of these projects, the x86 architecture requires
at least minimal use of segmentation. In order to install interrupts
and manage processes you will need to understand what a segment
is.  Luckily, it is simpler to set up segmentation for Project 1
than it will be for you to set up virtual memory in Project 3
(especially since we have done much of the work for you).<p>

A segment is simply a portion of the address space. Once defined, we can
associate important characteristics with the segment, like the privilege level
required to access the segment or whether it contains code or data. A segment
does not need to represent memory that actually exists - for example, we could
define a segment ranging from 0 to 4GB (the entire 32 bit address space), even
though we might have only 128MB of physical memory.</p><p>

Because your kernels are going to be complicated enough as it is,
we will steer clear of segmentation by using only four segments.
These four segments all span the entire 32 bit address space
(overlapping each other completely). Two of them require privilege
level 0 to be accessed, and two of them require only privilege
level 3. Of each privilege level pair, one segment represents code
and the other data. We have set up these segments for you.</p><p>

In this project, since no code will execute in user mode, we will use
only the two PL 0 segments.  To refer to these segments when
configuring kernel data structures (such as IDT entries), use the
<code>SEGSEL_KERNEL_CS</code>
and
<code>SEGSEL_KERNEL_DS</code>
constants defined in <tt>410kern/x86/seg.h</tt>.  These numbers are
segment selectors, which are simply indices into another processor
data structure, the global descriptor table (GDT). The GDT is the
place we have defined our segments. You do not have to reconfigure it
or know its format, however.</p><p>

Please refer to our online document
<a href="http://www.cs.cmu.edu/%7E410/doc/segments/segments.html">x86 Segmentation for the
15-410 Student</a>
for a
more detailed explanation of segmentation.  Do not worry if parts of
it do not make sense at the moment as they will become clearer later
in the course.</p><p>

<a name="comdev"></a></p><h3><a name="comdev">Communicating with Devices</a></h3>
There are two ways to communicate with a device on the x86
architecture. The first is to send bytes to an I/O port. The second is
through memory-mapped I/O.<p>

Most devices in the x86 architecture are accessed through I/O ports.
These ports are controlled by special system hardware that has access
to the data, address, and control lines on the processor.  By using
special hardware instructions to read and write from these ports, we
can use I/O ports without infringing upon the normal address space of
the kernel or user applications. This is because these special
instructions tell the hardware that this "memory" reference is
actually an I/O port, not a location in actual memory.  For more
information on I/O ports, consult chapter 10 of intel-arch.pdf.  Both
the timer and the keyboard use I/O ports. For convenience, an
assortment of C wrapper functions are provided to you to save you from
having to break into assembly language to read or write I/O
ports. These are located in <tt>410kern/x86/asm.h</tt>.  The various
<tt>in</tt> functions read from an I/O port while the <tt>out</tt>
functions write to an I/O port.  The letter after the name indicates
the size of the data being sent (b - byte, w - word/short, l -
long/int).  For this project, in which you will be talking only to
primeval 8-bit I/O devices which date to the 1980's, you will probably
need only the byte-wide versions of these instructions, i.e.,
<code>outb()</code> and <code>inb()</code>.</p><p>

There are also some devices which are accessed by reading and writing
particular addresses in traditional memory.  This is called
"memory-mapped I/O". This kind of memory <i>is</i> part of the regular
address space and therefore needs to be carefully managed.  <em>The
video display hardware uses both memory-mapped I/O and I/O ports, so
you must clearly understand the distinction.</em></p><p>

<a name="interrupts"></a></p><h3><a name="interrupts">Hardware Interrupts</a></h3> A kernel
programmer often uses either I/O ports or memory-mapped I/O to send
commands to devices (ranging in size from single byte commands to many
words). How do hardware devices communicate with the kernel?  When a
packet arrives at a network interface, the user presses a key on the
keyboard or moves the mouse, or any other type of event occurs at a
hardware device, that device needs a way of getting the attention of
the kernel. One way is for the kernel to keep asking the device if it
has something new to report (either periodically or
continuously). This is called polled I/O. However, this is wasteful of
CPU time, and there is a better mechanism. That mechanism is the
hardware interrupt.<p>

When a device wants to raise a hardware interrupt, it communicates
this desire to one of two programmable interrupt controllers (PICs) by
asserting some control signals on interrupt request (IRQ) lines. The
PICs are responsible for serializing the interrupts (taking possibly
simultaneous interrupts and ordering them), and then communicating the
interrupts to the processor through special control lines. The PICs
tell the processor that a hardware interrupt has occurred and which
request line the interrupt occurred on so the processor knows how to
handle the interrupt.  How devices are assigned to particular
interrupt request lines is extremely complicated, but there are some
conventions which are usually followed, displayed below.</p><p>

<table>
<tbody><tr>
<td>
<table border="">
<tbody><tr><td></td><td><center>PIC 1</center></td></tr>
<tr><td>0</td><td>Timer</td></tr>
<tr><td>1</td><td>Keyboard</td></tr>
<tr><td>2</td><td>Second PIC</td></tr>
<tr><td>3</td><td>COM2</td></tr>
<tr><td>4</td><td>COM1</td></tr>
<tr><td>5</td><td>LPT2</td></tr>
<tr><td>6</td><td>Floppy Disk</td></tr>
<tr><td>7</td><td>LPT1</td></tr>
</tbody></table>
</td>
<td>
<table border="">
<tbody><tr><td></td><td><center>PIC 2</center></td></tr>
<tr><td>8</td><td>Real Time Clock</td></tr>
<tr><td>9</td><td>General I/O</td></tr>
<tr><td>10</td><td>General I/O</td></tr>
<tr><td>11</td><td>General I/O</td></tr>
<tr><td>12</td><td>General I/O</td></tr>
<tr><td>13</td><td>Coprocessor</td></tr>
<tr><td>14</td><td>IDE Bus</td></tr>
<tr><td>15</td><td>IDE Bus</td></tr>
</tbody></table>
</td>
</tr>
</tbody></table>
</p><p>

The PIC chip used in old IBM compatibles only had 8 interrupt request (IRQ)
lines. This proved to be limiting, so a second PIC was daisy-chained off of the
first one. When an interrupt is triggered on the second PIC, it in turn
triggers an interrupt on the first PIC (on IRQ 2). The interrupt is then
communicated to the processor.</p><p>

Once the processor receives an interrupt from the PIC, it needs to know how to
respond. The processor reads a data structure called the interrupt descriptor
table (IDT). There is a descriptor in this table for each interrupt. A
descriptor contains various information about how to resolve the interrupt,
most importantly where the interrupt handler is located. The interrupt handler
is a piece of code that the author of the device driver writes that gets
executed when that device issues an interrupt. The IDT also stores the
privilege level that is required to call the handler (DPL) and the segment to
use while running the handler (which determines the privilege level to run
under).  Once the processor locates the appropriate entry in the IDT, it saves
some information about what it was doing before the interrupt occurred, then
starts executing at the address of the interrupt handler. Once the interrupt
handler has run to completion, the processor uses the saved information to
resume its previous task. Note that IRQ numbers do not necessarily correspond
to matching indices into the IDT. The PICs have the ability to map their IRQ
lines to any entry in the IDT. You will be given information on which IDT
entries correspond to interrupts pertaining to your projects.  For Project 1,
the IDT entries will correspond to the timer interrupt and the keyboard
interrupt.  These IDT entries are further discussed in their respective
sections. </p><p>

Interrupt handlers typically need to execute as quickly as possible so that the
processor is free to accept future interrupts. When an interrupt is sent by the
PIC, the PIC will not send another interrupt from that same source until it
gets acknowledged through an I/O port. This is because interrupt handlers
usually manipulate critical data structures and would not withstand being
interrupted by new invocations of themselves (i.e. they are not reentrant). In
particular, an interrupt handler must never block on anything. Most interrupt
handlers simply make a note of work that must be done as a result of the
interrupt, clear the interrupt, then terminate, leaving the work to be done at
a more convenient time. Note that it may be possible for one interrupt handler
to be interrupted by a different interrupt handler, so long as they do not
share data structures.

<a name="exceptions"></a></p><h3><a name="exceptions">Traps and Exceptions</a></h3>
Actual interrupts are issued by hardware asynchronously to the
instruction stream.  If a program wishes to voluntarily
depart from its normal execution path to invoke a kernel service,
it can enter the mysterious underworld through a "trap door" by
issuing a trap instruction.  Because Intel refers to traps as
"software interrupts", the x86 instruction is <code>INT n</code>,
which causes the processor to execute the n'th handler in the
IDT.

In addition to hardware and software interrupt handlers, the IDT also contains
information about exception handlers. Exceptions are conditions in the
processor that are usually unintended and need to be addressed. Page faults,
divide-by-zero, and segmentation faults are all types of exceptions.

In Project 2 you will use system calls (and accidentally invoke
exception handlers, to your sorrow).  In Project 3 you will
implement both system calls and exception handlers.  For Project 1
our concern will be installing interrupt handlers.

<a name="confint"><h3>Configuring Interrupts</h3></a>
As mentioned previously, an x86 processor uses the interrupt descriptor table
(IDT) to find the address of the proper interrupt handler when an interrupt
occurs. To install your keyboard (and timer) interrupt handler, you will have
to install an entry in this table.<p>

An entry in the IDT can be one of three different types: a task gate,
an interrupt gate, or a trap gate (a "gate" is just a descriptor that
contains information about a transition to a different piece of code -
think "gate to new procedure"). We will not be using task gates
because they make use of the processor's hardware task switching
functionality (which we also will not use for reasons we will discuss
later in the course). The difference between an interrupt gate and a
trap gate is that when the processor accesses an interrupt handler
through an interrupt gate, it clears a flag in one of the processor's
registers to defer all further interrupts until the current handler
returns. Handling interrupts through trap gates does not do this. (Why
might you not want to defer all other interrupts?)</p><p>

For the interrupts in this project, we will be using trap gates
(in later projects you will probably use a mixture of trap and
interrupt gates).  Note that a single interrupt source (timer,
keyboard, etc.) will not signal a new interrupt to the processor
until the processor has indicated that handling of the previous
interrupt from that source is ``done'', even if the system-wide interrupt-enable
flag is on.  You will need to give careful consideration to how
long it is reasonable to defer interrupts globally and how long
it is reasonable to wait before acknowledging a particular interrupt.</p><p>

The format of the trap gate is given on page 151 of
intel-sys.pdf. Note that regardless of the type of the gate, the
descriptor is 64 bits long.  Each gate is stored as two consecutive
32-bit words, with the first representing the least significant 32
bits of the gate.  You can use this fact to index into the IDT without
knowing the type of the other gates in the table. To get the base
address of the IDT, we use an instruction called <code>SIDT</code>. We
have provided a C wrapper function, <code>idt_base()</code>, for this
instruction so you do not have to break into assembly. This is
supplied in <tt>410kern/x86/asm.h</tt>.</p><p>

Initially (and inconveniently for us), the PICs are programmed so that
they call entries in the IDT that conflict with processor
exceptions. The base code which runs before your <tt>kernel_main()</tt>
invokes the
<tt>interrupt_setup()</tt> function to
remap the PICs to higher IDT entries, which agree with the constants
we provide you for the timer and keyboard IDT slot numbers.</p><p>

Some fields in the trap gate are self-explanatory, however others are not so they are summarized here:<br>
<table border="1">
<tbody><tr><td>DPL</td><td>The privilege level required to call the 
handler. If it is set to 3, then user processes can call the handler 
directly. For gates that handle hardware interrupts (like the keyboard 
and timer), it should be set to 0.</td></tr>
<tr><td>Offset</td><td>The offset into the segment of the interrupt 
handler. Since all of our segments take up the whole address space, this
 is simply the address of your function handler. This can be obtained in
 C by typing the name of the function (without any parenthesis or 
arguments).</td></tr>
<tr><td>Present (P)</td><td>Must be set to 1 for a working gate.</td></tr>
<tr><td>Segment Selector</td><td>The segment selector for the target 
code segment. This defines the privilege level the handler will run at. 
 The interrupt handler is going to be executed at PL0 and it is code, so
 this needs to be set to <code>SEGSEL_KERNEL_CS</code>.</td></tr>
<tr><td>D</td><td>Size of the gate.  All our gates are 32 bits (D = 1).</td></tr>
</tbody></table></p><p>

This may be the first time you are required to write code which packs a data
structure into a hardware-defined memory format.  There are several different
ways to write this kind of code.  Please make sure that, regardless of the
approach or style you use, your code is structured in a reasonable way.</p><p>

<a name="writingint"></a></p><h3><a name="writingint">Writing an Interrupt Handler</a></h3> As
mentioned above, when the processor receives an interrupt it uses the
IDT to start executing the interrupt handler. Before the interrupt
handler executes, however, the processor pushes some information onto
the stack so that it can resume its previous task when the handler has
completed. The exact contents and order of this information is
presented on page 153 of intel-sys.pdf. In Project 1 there are no user
tasks, so the processor will be executing in PL0 all the time. This
means interrupts will not cause a privilege level change, so the
EFLAGS (a system register containing an assortment of important
flags), current code segment, and the instruction pointer will be
pushed on the stack. For Project 1 there is no error code - this is
for exception handlers.<p>

This information is indeed enough to resume executing whatever code
was running when the interrupt first arrived. However, in order to
service the interrupt we need to execute some code; this code will
clobber the values in the general purpose registers. When we resume
executing normal code, that code will expect to see the same values in
the registers, as if no interrupt had ever occurred. So the first
thing an interrupt handler must do is save all the general purpose
registers, plus %ebp. We need not save the stack pointer because if
there is no stack change (as is the case in this project since we have
no user processes), the stack pointer will be correct once we pop off
all of our interrupt-related information. If there is a stack change
(as there will be in Project 3 when you do have user processes), the
interrupt saves the stack pointer for us. So, to recap, the registers
<b>you</b> need to save are %eax, %ebx, %ecx, %edx, %esi, %edi, and
%ebp.</p><p>

The easiest way to save these registers is to just save them on the
stack. This is easily done with the <code>PUSHA</code> and
<code>POPA</code> instructions (more information on these can be found
on pages 624 and 576 of intel-isr.pdf). To save the registers before
anything else occurs, part of your interrupt handler, which we will
call a "wrapper", will be written in assembly language. All you must
do in assembly is save the registers, call your C handler (try the
<code>CALL</code> instruction), then restore the registers. To return
from an interrupt, we recommend the <code>IRET</code> instruction,
which you doubtless will wish to read up on.  It uses the information
initially saved on the stack by the interrupt (EFLAGS, code segment,
instruction pointer) to return to the code executing when the
interrupt occurred.  PLEASE THINK ABOUT WHY AN ASSEMBLY WRAPPER IS
USED HERE. </p><p>

A final note about writing assembly. Comment your assembly profusely. One
comment per instruction is not a bad rule of thumb.  Assembly code should
be grouped into files according to function according to the same principles
you use to group C code into files.
To export a symbol
(e.g., <code>asm_timer_wrapper</code>)
so it is visible outside the file containing it, use the <code>.globl</code>
directive:</p><p>

<code>.globl asm_timer_wrapper</code></p><p>

For those of you who have not written assembly before, here is the expected form: </p><p>

<code>
.globl function_name<br>
function_name:<br>
&nbsp;&nbsp;&nbsp;&nbsp; assembly_instruction1 #comment<br>
&nbsp;&nbsp;&nbsp;&nbsp; assembly_instruction2 #comment<br>
&nbsp;&nbsp;&nbsp;&nbsp; assembly_instruction3 #comment<br>
&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
</code>
</p><p>

Assembly files normally have a .s or .S extension.  The two extensions have
different meanings to gcc; gcc will run the preprocessor on assembly files
named with .S, while it passes files ending in .s to the assembler unaltered.
Since you'll probably want to use <tt>#define</tt>s and other preprocessor
statements within your assembly code, we strongly suggest naming your assembly
with the .S extension. Note that the C preprocessor will swallow C-style
comments in your .S files so they won't annoy the assembler.</p><p>

For C code to call your assembly-language functions, you should declare them in a header (.h) file.
This is a good place for you to place doxygen comments for the assembly-language code.</p><p>

<a name="consolespec"></a></p><h2><a name="consolespec">Console Device Driver Specification</a></h2>

The job of the console device driver seems simple: take characters and print
them on the screen. For the most part, it is that simple. Keep in mind that
this console will be the front end of your kernel for the rest of the semester,
however. For this reason you will probably want it to do a few basic things
like scroll when the output reaches the bottom of the console, line wrap when a
line exceeds the width of the console, etc. The first thing to do is to
understand how to print a single character to the console.

<a name="writingchar"><h3>Writing a Character to the Console</h3></a>

When operating in primeval text mode, the job of a PC graphics adaptor and
an attached CRT display is to
convert a rectangular array of character-display information into a rectangular
array of <a href="http://www.physics.isu.edu/radinf/beta.htm">beta
radiation</a>, which is beamed toward your face by a linear accelerator.  Much
of this radiation is converted to photons by a layer of toxic phosphorous
compounds.  Starting Project 1 early will afford you the opportunity to take
occasional breaks from exposure to this complex mixture of subatomic particle
radiation.
(If you use an LCD display instead of a CRT, you will be taking a break
from exposure to UV from the fluorescent backlight.)<p>

The pixel pattern displayed by the graphics adaptor is controlled by a region
of main memory (memory mapped I/O).  Each character on the console is
represented in this region by a byte pair.  The first byte in this pair is
simply the character itself.  The second byte controls the foreground and
background colors used to draw the character.  These byte pairs are stored in
row-major order.  We have configured your graphics controller to paint a screen
consisting of 25 rows of 80 characters each.  The location of video memory, as
well as the color codes used for the second byte of each pair, are defined in
<tt>410kern/x86/video_defines.h</tt>.</p><p>

Writing a character to the console is as simple as writing a byte pair to video
memory. For example to write the character 'M' on
the third character of the second line (since we will number from 0,
this is row 1, column 2), you would do something like this:</p><p>

<code>
<br>
*(char *)(CONSOLE_MEM_BASE + 2*(CONSOLE_WIDTH + 2)) = 'M';
<br>
*(char *)(CONSOLE_MEM_BASE + 2*(CONSOLE_WIDTH + 2) + 1) = console_color;
<br>
</code>
</p><p>

where <code>CONSOLE_MEM_BASE</code> is the start location of the console
memory, <code>CONSOLE_WIDTH</code> is the width of the console in characters
(defined to be 80), and console_color is a variable containing the current
foreground and background color specification of your choice.</p><p>

While our support code has already put the hardware in 80x25 format, you will
also need to reposition or hide the hardware cursor.  The hardware cursor is
controlled by the Cathode Ray Tube Controller (CRTC), an important device on
the video card.  Communication with the CRTC is accomplished with a special
pair of registers.  Accessing these registers is a little different from
writing to console memory as they use the I/O ports (<a href="#comdev">discussed earlier</a>).</p><p>

<a name="commcrtc"></a></p><h3><a name="commcrtc">Communicating with the CRTC</a></h3>

The CRTC is one of the devices which is accessed through I/O ports. It has two
registers, an index register and a data register. The index register tells the
CRTC what function you are performing on it, such as setting the hardware
cursor position. The data register then accepts a data value associated with
the operation. Because the data register is only one byte long, and the offset
of the hardware cursor (which is measured in single bytes, not two-byte pairs)
is a 16-bit integer, setting the hardware cursor position is done in two steps.
The commands to send to the CRTC, as well as the location of the CRTC I/O
ports, are defined in <tt>410kern/x86/video_defines.h</tt>. To hide the
hardware cursor completely, simply set the position to an offset greater than
the size of the console.

<a name="consoleint"><h3>Console Device Driver Interface</h3></a>

Now that you know how to write characters to the console and move/hide the
hardware cursor, you have the primitives you need to build a console device
driver. Here is the API that you need to implement for the driver.  Note that
the API description refers to a <em>logical</em> cursor, a sometimes-visible
indicator of where the next character will be placed on the screen.  You are
responsible for manipulating the hardware cursor-offset register as necessary
to make sure the logical cursor's visual appearance on the screen is correct.
This is a <em>design issue</em>: understanding what is being asked of you will
require some analysis; there is more than one solution; the clarity and quality
of your solution will influence your grade.

<p><tt>int putbyte(char ch);</tt><br>
Description:  Prints character ch at the current location of the cursor.  If
the character is a newline ('\n'), the cursor should be moved to the first
column of the next line (scrolling if necessary).  If the character is a
carriage return ('\r'), the cursor should be immediately reset to the beginning
of the current line, causing any future output to overwrite any existing output
on the line.  If backspace ('\b') is encountered, the previous character should
be erased (write a space over it and move the cursor back one column).  It is
up to you how you want to handle a backspace occurring at the beginning of a
line.<br> Returns: The input character.</p><p>

<tt>void putbytes(const char* s, int len);</tt><br>
Description: Prints the character array s, starting at the current location of
the cursor. If there are more characters than there are spaces remaining on the
current line, the characters should fill up the current line and then continue
on the next line. If the characters exceed available space on the entire
console, the screen should scroll up one line, and then printing should
continue on the new line.  If '\n', '\r', and '\b' are encountered within the
string, they should be handled as per putbyte. If len is not a positive integer
or s is null, the function has no effect.  When you scroll the screen, you are
not required to remember characters which are "pushed off" of the screen.<br>
<tt>const char* s</tt>: The character array to be printed.<br>
<tt>int len</tt>: The number of characters to print from the array.<br>
Returns: Void.</p><p>

<tt>void draw_char(int row, int col, int ch, int color);</tt><br>
Description:  Prints character ch with the specified color at position 
(row, col).  If any argument is invalid, the function has no effect. <br>
<tt>int row</tt>: The row in which to display the character. <br>
<tt>int col</tt>: The column in which to display the character. <br>
<tt>int ch</tt>: The character to display. <br>
<tt>int color</tt>: The color to use to display the character. <br>
Returns: Void.</p><p>

<tt>char get_char(int row, int col);</tt><br>
Description:  Returns the character displayed at position (row, col).<br>
<tt>int row</tt>: Row of the character. <br>
<tt>int col</tt>: Column of the character. <br>
Returns: The character at (row, col)</p><p>

<tt>int set_term_color(int color);</tt><br>
Description: Changes the foreground and background color of future 
characters printed on the console. If the color code is invalid, the 
function has no effect.<br>
<tt>int color</tt>: The new color code.<br>
Returns: 0 on success, or integer error code less than 0 if color code is invalid.</p><p>

<tt>void get_term_color(int* color);</tt><br>
Description: Writes the current foreground and background color of characters printed on the console into the argument color.<br>
<tt>int* color</tt>: The address to which the current color information will be written.<br>
Returns: Void.</p><p>

<tt>int set_cursor(int row, int col);</tt><br>
Description: Sets the position of the cursor to the position (row, col).
 Subsequent calls to putbyte or putbytes should cause the console output
 to begin at the new position. If the cursor is currently hidden, a call
 to set_cursor() must not show the cursor.<br>
<tt>int row</tt>: The new row for the cursor.<br>
<tt>int col</tt>: The new column for the cursor.<br>
Returns: 0 on success, or integer error code less than 0 if cursor location is invalid.</p><p>

<tt>void get_cursor(int* row, int* col);</tt><br>
Description: Writes the current position of the cursor into the arguments row and col.<br>
<tt>int* row</tt>: The address to which the current cursor row will be written.<br>
<tt>int* col</tt>: The address to which the current cursor column will be written.<br>
Returns: Void.</p><p>

<tt>void hide_cursor();</tt><br>
Description:
Causes the cursor to become invisible, without changing its location.
Subsequent calls to putbyte or putbytes must not cause the cursor
to become visible again.
If the cursor is already invisible, the function has no effect.<br>
Returns: Void.</p><p>

<tt>void show_cursor();</tt><br>
Description:
Causes the cursor to become visible, without changing its location.
If the cursor is already visible, the function has no effect.<br>
Returns: Void.</p><p>

<tt>void clear_console();</tt><br>
Description: Clears the entire console and resets the cursor to the home
 position (top left corner).  If the cursor is currently hidden it 
should stay hidden.<br>
Returns: Void.</p><p>

<a name="timerspec"></a></p><h2><a name="timerspec">Timer Device Driver Specification</a></h2>
Unlike the console, the timer generates interrupts that must be handled
properly. If you do not handle timer interrupts quickly enough, the timer will
generate the next timer interrupt before the PIC has been reset by your timer
interrupt handler, and a timer interrupt will be lost.  This may not seem like
a big deal, but even if you miss just 0.1% of the interrupts, after one day
your clock would already be minutes off.<p>

The actual timer interrupt handler in this project is quite simple, although in
Project 3 you will be using the timer interrupt to trigger your scheduler.  For
this project, you'll be using the timer interrupt to measure elapsed times.

<a name="conftimer"></a></p><h3><a name="conftimer">Configuring the Timer</a></h3>
Communicating with the timer is done through I/O ports. These I/O ports are
defined in <tt>410kern/x86/timer_defines.h</tt>. Also defined in that file
is the internal rate of the PC timer,
1193182 Hz (please memorize this number, as it will be used as an encryption
key in a final exam question). Fortunately, we can configure the timer to give
us interrupts at a fraction of that rate. For Project 1, you should configure
the timer to generate interrupts every 10 milliseconds.<p>

To initialize the timer, first set its mode by sending
<code>TIMER_SQUARE_WAVE</code> (defined in
<tt>410kern/x86/timer_defines.h</tt>) to the
<code>TIMER_MODE_IO_PORT</code>. The timer will then expect you to send it the
number of timer cycles between interrupts. This rate is a two-byte quantity, so
first send it the least significant byte, then the most significant byte. These
bytes should be sent to the <code>TIMER_PERIOD_IO_PORT</code>.</p><p>

When the timer interrupt occurs the processor consults the IDT to find out
where the timer handler is. The index into the IDT for the timer is
<code>TIMER_IDT_ENTRY</code>. You will need to fill in this IDT entry for your
timer handler to execute properly.</p><p>

Your timer interrupt handler should save and restore the general purpose
registers. You also need to tell the PIC that you have processed the most
recent interrupt that the PIC delivered. This is done by sending an
<code>INT_ACK_CURRENT</code> to one of the PIC's I/O ports,
<code>INT_CTL_PORT</code>. These are defined in
<tt>410kern/x86/interrupt_defines.h</tt>.</p><p>

<b>Note:</b> You will be testing this on an instruction set simulator. Even
though you are simulating an older processor on relatively fast machine, Simics
does not make an effort to exactly correlate the simulation to real wall clock
time. If you have it set up properly, it will run in real time on real
hardware.

<a name="timerint"></a></p><h3><a name="timerint">Timer Device Driver Interface</a></h3>

Your timer interrupt handler is required to call an application-provided
clock-tick callback function each time the timer interrupt fires.
This callback function will be passed an unsigned integer
<tt>numTicks</tt>
containing the total number of timer interrupts your handler has caught
since the game kernel began running.
Your driver will know the address of the callback function because
it will be passed as a parameter
to the <tt>handler_install()</tt> function (see below).

Each application linked against your device-driver library will provide its
own callback function (which could be as simple as immediately returning
to your handler).  Timer callbacks should run "quickly", meaning that
they should return <em>long</em> before the next timer interrupt will
arrive.

<a name="keyspec"><h2>Keyboard Device Driver Specification</h2></a>

Like the timer, the keyboard is also interrupt driven.  Unlike timer
interrupts, keyboard interrupts signify the availability of data
which needs to be processed.  The two functions of the keyboard driver
are buffering data from the interrupt handler and converting the
the keyboard's messages into a convenient format.<p>

<a name="interactkey"></a></p><h3><a name="interactkey">Interacting with the Keyboard</a></h3>

The keyboard hardware doesn't speak in characters--pressing the "A"
key doesn't result in an 'A' (or 'a') byte being sent to the CPU.
For one thing, the keyboard reports not only key presses but also
key releases (so if you want to type an uppercase "A" the keyboard
will typically report this sequence of four events:
shift-pressed, a-pressed, a-released, shift-released).
A further complication is that while most events fit into one byte,
some events related to "advanced" or "special" keys, such as the
arrows, cause the keyboard hardware to transmit several bytes to
the CPU.  In general, a logical event such as "A" or "right arrow"
involves the keyboard controller sending approximately four
one-byte "scan codes" to the processor,
including the delivery of one interrupt per scan code.<p>

Luckily the 410 support code includes a function,
<tt>process_scancode()</tt>, declared in
<tt>410kern/x86/keyhelp.h</tt>,
which encapsulates a complicated state machine.
Each time you pass a scancode to <tt>process_scancode()</tt>,
it will return a 4-byte "augmented character" describing the state
of the keyboard's world after the scan code has been processed.
The "augmented character" may be broken down by a family of
helper macros to determine whether a key was pressed or released,
which "modifier keys" (shift, control, alt) were held down at
the time, and whether the most recent scancode completed the
specification of a particular character.  The augmented-character
interface is discussed further below.</p><p>

The index into the IDT for the keyboard is <code>KEY_IDT_ENTRY</code> (defined in
<tt>410kern/x86/keyhelp.h</tt>).  When you receive a keyboard interrupt,
your keyboard handler needs to read the scancode from the keyboard by reading a
byte from the keyboard's I/O port (<code>KEYBOARD_PORT</code>, also from
<tt>keyhelp.h</tt>). You also need to tell the PIC that you
have processed the keyboard interrupt. This is done by sending a
<code>INT_ACK_CURRENT</code> to one of the PIC's I/O ports,
<code>INT_CTL_PORT</code> (see <tt>410kern/x86/interrupt_defines.h</tt>).</p><p>

So that your device driver library might be used by the widest range of
applications, such as a real-time game, we will ask you to structure your
keyboard interrupt handler so it does as little work as reasonably possible.
In particular, you should postpone processing the scan code until you are no
longer inside an interrupt handler.  In other words,
you should assume in Project 1 that the
<tt>process_scancode()</tt> function is computationally expensive,
so that performing that processing in the keyboard interrupt handler
might disrupt the application.  Please note: this restriction is
specific to Project 1, not an eternal fact about all software in
the universe!</p><p>

Do not forget that your keyboard interrupt handler needs to save and restore
the general purpose registers! Also, we have included functions that enable and
defer interrupts in <tt>410kern/x86/asm.h</tt> (namely
<tt>enable_interrupts()</tt> and <tt>disable_interrupts()</tt> respectively).
You may need to use them in your keyboard driver to ensure
there are no interrupt-related concurrency problems.  Certain implementations
may not need them.  Be sure to document the reasoning behind your use or
non-use of interrupt deferral.</p><p>

<a name="keyint"></a></p><h3><a name="keyint">Keyboard Device Driver Interface</a></h3>
The keyboard device driver has a very simple interface - it is just one function, readchar().<p>

<tt>int readchar();</tt><br>
Description: Returns the next character in the keyboard buffer. This 
function does not block if there are no characters in the keyboard 
buffer.<br>
Returns: The next character in the keyboard buffer, or -1 if the keyboard buffer does not currently contain a valid character. </p><p>

Note that this interface is a deliberate simplification--a client
of this interface can't tell whether an "A" was generated by
holding down the left shift key or the right.
Some applications, such as games, might prefer to use the
augmented characters returned by <tt>process_scancode()</tt>.

For <tt>readchar</tt> to simplify augmented characters into
regular ones, it will need to invoke the following macros:
</p><ul>
  <li><tt>KH_HASDATA(augchar)</tt> returns true if the augmented
	  character specifies a particular character value (for example,
	  feeding <tt>process_scancode()</tt> a "left-shift-down"
	  scancode will probably return an augmented character
	  which does not specify a character value).
  </li><li><tt>KH_ISMAKE(augchar)</tt> returns true if the augmented
	  character specifies a press event instead of a release event.
	  Recall that when "a" is typed, the keyboad will generate both
	  a "make" (press) event and a "break" (release) event.
  </li><li>If a character is specified, <tt>KH_GETCHAR(augchar)</tt> returns
	  the character itself--for example, 0x41 for an "A".  Some
	  keys, such as arrows, are represented by "extended character"
	  values defined in the <tt>kh_extended_e</tt> enumeration in
	  <tt>keyhelp.h</tt>.
</li></ul>

<tt>readchar()</tt> will not need to worry about the state of the
modifier keys (shift, control, alt, caps-lock, num-lock, scroll-lock),
though this information is available via other macros (e.g., <tt>KH_SHIFT</tt>).<p>

Additional documentation, for the enthusiastic, is available at
<a href="http://www.cs.cmu.edu/%7E410/doc/enthusiast.html">410 Documentation For The Enthusiast</a>.

<a name="FPU"></a></p><h3><a name="FPU">Floating-Point Unit (FPU)</a></h3>

The base code which runs before your 
<tt>kernel_main()</tt> function
has disabled the floating-point unit.
FPU's are fascinating and complex and the x86 FPU
is particularly fascinating (difficult to manage).
Because we will not require your kernel to correctly
implement floating point,
now is a good time to get in the habit of writing
integer-only code.

<a name="defkernel"><h2>Skeleton Kernel</h2></a>

There is a lot of functionality missing in our bare kernel - there is no
virtual memory and no filesystem, and none of the devices are initialized.
However, we have taken care of some of these things for you, such as
bootstrapping.  We also have provided many of the standard C library functions
you know and love (see the next section).  The entrypoint into the kernel is
the <tt>kernel_main()</tt> function in <tt>kern/game.c</tt>,
which is called after bootstrapping.
This function does various setup work and then calls your device library's
<tt>handler_install()</tt> function to specify the address of the
timer-tick callback routine and request activation of the driver
library.
In addition, we have provided <tt>kern/fake.c</tt> containing
empty versions of functions which you must implement and <tt>spec/p1kern.h</tt>
containing the prototypes for those functions to get you started.<p>

<a name="cfunctions"></a></p><h3><a name="cfunctions">Provided C Functions</a></h3>
We have provided many of the standard C library functions for you.  To see
which functions, feel free to look at the following header files in the
<tt>410kern/stdlib</tt> directory:<br>
ctype.h<br>
malloc.h<br>
stdio.h<br>
stdlib.h<br>
string.h<br><p>

Although various printing functions are provided in stdio.h (namely printf(),
putchar(), and puts()) they <strong>will not work</strong> until you implement
<tt>putbyte()</tt> and <tt>putbytes()</tt>. (Note, though, that implementing
only one or the other will cause those functions to behave unpredictably;
it will not prevent them from making output!)</p><p>

Also, we have provided a function called <code>lprintf()</code>
and a <code>MAGIC_BREAK</code> macro (in <tt>410kern/simics/simics.h</tt>)
that you may find useful for debugging purposes.
<code>lprintf()</code> works like <code>printf()</code>, but will send its
output to Simics (not to the console you're writing) and to the kernel.log file.
Unlike <code>printf()</code>, <code>lprintf_kern()</code> does not depend on any
of your console device driver functions.
Whenever a <code>MAGIC_BREAK</code> is encountered within your
code, Simics will act as if it has reached a previously-set breakpoint and will
enter debugging mode.</p><p>

<a name="testing"></a></p><h2><a name="testing">Testing</a></h2>
It is very important to thoroughly test the console, timer, and keyboard driver
on your own before moving on to implement your game.  Your game (described
next) will NOT test the complete functionality expected in these drivers.  You
will be provided with a 410_test.c that you can use to make sure your drivers
are working.  This will NOT be a complete test.  We will run our own version of
410_test.c and other tests to check your functionality.  Extensive testing is
also in your best interest since you will use your own drivers again for
Project 3.<p>

<a name="tying"></a></p><h3><a name="tying">Tying it All Together</a></h3>

Congratulations. By now you should have a console driver, a timer
driver, and a keyboard driver. These can now be used by any
application which is linked against them, such as 410_test or your
game application. The build set up should already link 410_test.c and
game.c against your drivers. It is each application's
responsibility to provide a <tt>kernel_main()</tt> function and a
clock-tick callback
function as described above. When you launch Simics, the
boot loader will let you choose between "Game" and "Tester" (see the
BIOS and Bootloader section below).


<a name="game"><h3>Number Munchers</h3></a>

<!-- start -->

<p>The game you will be implementing is
<a href="http://en.wikipedia.org/wiki/Number_Munchers">Number Munchers</a>,
a game where you move around a board "munching" multiples of a
number. Your progress will be impaired by monsters trying to eat you. The
objective of the game is to eat all multiples of the given number on the
board and progress to the next level. You can try the game yourself at <a href="http://www.numbermunchers.org/muncher1.html">numbermunchers.org</a>.</p>

<p><img src="number_munchers_files/number_muncher.html" alt="sample" title=""></p>

<p><strong>a minimal, but acceptable game of number munchers in progress</strong></p>

<p>Your implementation is required to have a 6x6 board.
For each level, the base number whose multiples will be munched will be randomly selected,
and then random multiples of that base number will be distributed randomly on roughly 1/3
of the board. The rest of the board will be filled in with numbers that
are not multiples.
All numbers, muchable or not, should be of reasonable magnitude
(the game player should not be required to compute that
1428 = 17 * 84).</p>

<p>The player begins at a random position on the board and moves around the
board via the keyboard.
The controls should be reasonable (e.g., w/a/s/d, h/j/k/l, arrow keys...),
not something silly like u/d/l/r!
The player hits a designated key (we recommend the space bar)
to eat the number that they are on.
The board does not "wrap around": if the player tries to move left from
the leftmost edge of the board, nothing happens.</p>

<p>When a player munches a number, that number disappears.
If the number is in fact a multiple of the base,
then the score is adjusted.
Otherwise, one of the three lives of the player is removed.</p>

<p>Each level also has some monsters, and these monsters eat the player
if they are ever in the same square as the player.
When eaten, the player
loses one of his or her three lives.
Eaten players with lives left are
moved to a random monster-free location on the board.
Level 1 has
up to 1 monster, level 2 has up to 2, level 3 has up to 3, etc. If a
monster is ever on top of another monster, it eats the monster it has
landed on. Eaten monsters no longer participate in the level and no
extra monsters should be spawned as a result.</p>

<p>Each time the player moves to a different square,
the game moves each monster once.
Monster moves are processed one at a time in some order chosen by the game.
Once the player and all existing monsters have moved, new monsters may
be spawned (see below).
When a player munches a number, the monsters do not move.</p>

<p>At the beginning of the game, the player is located at a random
location on the grid and there are no monsters. Each subsequent move
of the player spawns a new monster (one at a time, up to the limit of
monsters for the level). Monsters will appear at random locations on the
periphery of the board. Monsters cannot spawn on top of the player, but they
can spawn on top of one another (resulting in one being eaten).
</p>

<p>Monsters come in four different flavors, and each is just as likely to occur as the others:</p>

<dl>
<dt>Random monster </dt><dd> Moves in a random direction each time it moves
</dd><dt>Evil monster </dt><dd> Moves towards the player, except has a 
random chance of doing a random move (i.e. not moving or moving away 
from the player). It is up to you to choose a probability that doesn't 
ruin the game.
</dd><dt>Hungry monster </dt><dd> Has the same objective as the player, 
to eat all multiples. This monster will oppose the player by eating 
multiples on the board as well.
</dd><dt>Spiral monster </dt><dd> This monster will spiral away from its
 starting location. It is up to you what happens when the monster 
reaches the edge, although the monster should continue to spiral in some
 sense.
</dd></dl>

<p>A player's total score is the sum of the scores they have achieved on
 every level. The level on which the player died does not count towards 
the score. The following formula calculates the score for a level:</p>

<pre><code>4^(level) + (10 - seconds/10) + 3 * munched
</code></pre>

<p><em>level</em> is the number of the level you are on (1, 2, 3, ...), <em>seconds</em> is the number of seconds which it has taken to complete the level (not elapsed since start of game), and <em>munched</em> is the count of numbers that were munched on this level.</p>

<p>A minimal but acceptable implementation of Number Munchers should contain</p>

<ul>
<li>A title screen displaying your name and a high score.</li>
<li>An instruction screen describing how to play the game that can be accessed from both the game screen and the title screen.</li>
<li>A timer that displays the time in the current game.</li>
<li>An interactive game screen which displays the timer, the current 
score, the multiple to munch numbers for, the level number, number of 
lives left, and the board.</li>
</ul>

<p>You are encouraged to go beyond these minimum requirements but be sure to keep
 the following wisdom in mind.</p>

 <blockquote>
   <p>A game with a simple, functional UI is more likely to receive full credit than
   a beautiful game that doesn't work properly. In addition, there may be bugs in
   the drivers that become apparent only when they're tested on a completed game,
   and finishing the game can take longer than expected. For these reasons, it
   behooves you to write good driver code first, then a complete game that meets
   the requirements and is well tested, and to then use remaining time to write a
   more fully-featured game.</p>
</blockquote>

<p>
<b>Note about the timer:</b><br>
For your game to operate correctly when we test it, your program must
have some notion of real time.  We have asked you to program the timer
to interrupt the processor once every 10 milliseconds.  When executed
directly on hardware (e.g., when booting a PC from a floppy drive
containing your program), an interrupt will indeed occur once every 10
milliseconds with a fair degree of precision, provided that the timer
has been programmed correctly.  When emulated in Simics however, a
timer programmed to generate an interrupt every 10 milliseconds will
actually generate interrupts at a much slower rate.  For example,
when measured in real time, the timer may only generate an interrupt
every 500 milliseconds. (If time permits, the curious may wish to read
the notes about simulation time or other emulators at <a href="http://www.cs.cmu.edu/%7E410/doc/enthusiast.html">The 410
Documentation For The Enthusiast</a>.)  One of the ways to test your timer
configuration is to boot your game on real hardware.  There is a "crash box"
configured for this purpose.  Information about trying this is available <a href="http://www.cs.cmu.edu/%7E410/doc/crashbox.html">here</a>.  </p><p>


<!-- end -->

</p><p>
<b>Note about randomness:</b><br>
In general you need two things, namely a random seed and a
pseudo-random-number generation process.
Probably the easiest way for you to get a random seed involves timing
one or more keypress events.
There are other options as well.
For further reading on randomness within the machine,
see
<a href="http://egd.sourceforge.net/">EGD: The Entropy Gathering Daemon</a>.
We have provided you with
an implementation of the
<a href="http://en.wikipedia.org/wiki/Mersenne_twister">"Mersenne Twister MT19937"</a>
pseudo-random number generator (PRNG),
declared in
<tt>410kern/RNG/mt19937int.h</tt>.
<!-- BEGIN COMMENTED-OUT SECTION -->

<!-- END COMMENTED-OUT SECTION -->


<a name="doxygen"></a></p><h3><a name="doxygen">Documenting</a></h3>
As mentioned in the goals section, commenting is an important part of writing
code.  We will be using doxygen, which generates HTML documents similar to
javadoc.  Please see our <a href="http://www.cs.cmu.edu/%7E410/doc/doxygen.html">doxygen
documentation</a> to see how to include comments in your code that can be read
by doxygen.  When we grade your projects, this is the first thing we will look
at.  Lack of documentation will be reflected in your grade.  The provided
<tt>game.c</tt> and <tt>p1kern.h</tt> files contain example doxygen
comments with the sort of information we are expecting to see.  While doxygen
is equally happy to extract documentation from .c and .h files, documentation
should live with program text when possible.  For Project 1 this means that
assembly functions should be documented in a .h file and that we are providing
you with documentation for the console functions in a .h file, but otherwise
documentation should appear in .c files.  In addition, we have provided a rule
in the Makefile to take care of generating the documents for you.  This rule is
<tt>make html_doc</tt> and will be how we generate your documents.  <p>

Novice users often fall into the trap of believing that
if they document every procedure and get Doxygen to make pretty documentation
that they have adequately documented their program. It is <i>imperative</i> 
that you also document design decisions, rationale, algorithms, and invariants.
In general, you want to tell the reader a story that makes logical connections 
from top-level requirements down to implementation details.</p><p>

<a name="notes"></a></p><h3><a name="notes">Other Important Notes</a></h3>
<ul>
<li>Since we will be running and testing your code on Andrew Linux machines,
your code will be compiled, linked, and run under gcc 4.4.5.  If you are
working on AFS, then you don't have to worry about anything: the Makefile will
run <cmd>410-gcc</cmd>, <cmd>410-ld</cmd>, etc.  These wrapper scripts are
found in the 410 <code>bin/</code> directory, which you should have on your
<code>$PATH</code>.
If you are
working on some other machine, you can copy and adjust these shell scripts.
Check the version of gcc you are using by
running <tt>gcc --version</tt> on the command line.  If your gcc version is not
the same as ours, you must make sure that your code compiles, links, and runs fine under
the version we will use for grading.
</li><li>Please do not change any of the provided files in the <tt>410kern/</tt> subdirectory.
We will run your code using our versions of the files, so any changes you make will be lost.
<!--
<li>At times when you are working on your project, the Simics console will
suddenly announce "Double fault" (or even "Triple fault"!).
This generally means that the processor
tried to invoke an interrupt or exception handler but found that the IDT
entry was not valid.  When this happens, it is probably a good idea to
use the Simics debugger to determine which exception or interrupt the
processor encountered, figure out why that event took place, and come
up with a plan for dealing with the situation.  One way (but there are
plenty more!) to end up in this situation is to receive a timer interrupt
before your timer driver is complete (what could you do to avoid receiving
timer interrupts?).
For further information, you may wish to consult
<A HREF="http://www.cs.cmu.edu/~410-f10/doc/triple.html">our Triple-Fault Advice Page</A>.
-->

</li><li>Be sure that <code>handler_install()</code> completely installs and
initializes your driver code (and only your driver code) when it is invoked.
Our test code will be linked against and will invoke <code>handler_install()</code>,
but not any of your game code, before using the driver library.
</li><li>As noted above, the drivers should be thought of as a library 
provided to your game application.  Thus there should not be any game 
specific code in your driver implementations.
</li><li> By
<a href="http://www.freebsd.org/cgi/man.cgi?query=end&amp;sektion=3&amp;manpath=Unix+Seventh+Edition">long-standing
tradition</a>, in the Unix programming environment, the compiler toolchain defines certain symbols with
reserved names.  Avoid calling anything in your program <tt>etext</tt>, <tt>edata</tt>, or <tt>end</tt>.
</li><li>You should read the <a href="http://www.cs.cmu.edu/%7E410/doc/setup.html">Software Setup Guide</a> for more information on the software setup for this class and for information on files commonly found in the project tarballs.
</li></ul>
 

<a name="simics"><h2>Testing and Debugging with Simics</h2></a>
Debugging operating system code is typically quite difficult. One of way of
doing it is to have two machines, one running a standard production OS like
Linux, and the other running (and presumably crashing) the OS being developed.
A serial cable is used to attach the two machines and special serial handlers
installed on the development OS allow a debugger on the production OS to debug
the development code. Fortunately, you will not have to deal with this.

For the duration of this course, you will be testing and debugging your
projects with Simics. Simics is an instruction set simulator. This means that
every instruction that Simics runs is simulated, rather than run on real
hardware as in VMware. For this reason Simics runs quite a bit slower than
VMware.

<p>Because Simics simulates every instruction executed, it has some powerful
debugging capabilities. It allows, for example, breakpoints to be set on memory
accesses to certain locations (specifically reads, writes, executes, or any
combination thereof). It also allows temporal breakpoints - breakpoints that
occur after a certain number of instructions have been executed. Like the
popular debugger GDB (which most of you should be familiar with from 15-213) it
has some symbolic debugger capabilities as well.</p>

By typing <tt>help</tt> at the Simics prompt, you will be presented with a list
of different categories of commands.  To see the commands in a specific
category, type <tt>help CATEGORY</tt>.  To get help on any of these specific
commands, type <tt>help COMMAND</tt>.  Please see our <a href="http://www.cs.cmu.edu/%7E410/doc/simics_commands.html">Simics Commands Guide</a> for a list of
important commands to know.  In fact, any time you are at an impasse you
should re-read that Guide to see if you are using all the tools you have
at your disposal.

<p>Note: If you experiment with the VGA "blink" attribute, please be aware
that, while most hardware implementations will obey it, Simics does not.</p>

<a name="getsimics"><h3>Getting Started with Simics</h3></a>
<p>Simics has been installed on AFS and thus may be used from any Linux machine
connected to AFS, subject to licensing restrictions. If you have added the
15-410 bin directory to your path, you can execute Simics on your kernel by
executing <tt>simics4</tt> </p>

<!--
You may also use a Solaris machine, but your
code still must be compiled and run on a Linux machine (you can ssh into
linux.andrew.cmu.edu and compile and run there). -->

<p><a href="http://www.cs.cmu.edu/%7E410/doc/setup.html">Instructions</a> on getting Simics to work
within your development environment are on the <a href="http://www.cs.cmu.edu/%7E410/projects.html">Projects</a> section of the course website.</p>

<a name="biosboot"><h3>The BIOS and Bootloader</h3></a>

<p>
Before your kernel starts running, you will always see the BIOS startup
followed by the bootloader. We chose GRUB as our bootloader for various reasons
which we will not go into here. The bootloader has been configured to present
you with a boot menu consisting of two choices.  You will be able to choose
between running your video game or the 410_test program.</p>

<a name="triplefault"><h3>A Note on "Triple Faults"</h3></a>

<p>
At some point in your Simics career, you will probably encounter
a "triple fault" condition.  This means that while your operating
system was running it ran into an exception, and while that exception
was being handled a second exception was raised, and while
<em>that</em> exception was being handled a third one was raised.
At this point your average PC would just blank the screen and
reboot, leaving you eternally mystified about the cause (in
contrast, most non-PC computer systems provide a way to view
an exception traceback).  One of the nice things about Simics
is that it lets you easily debug this most difficult situation.
</p>



<p>
Triple faults are easy to run into in Project 1.
Since you are not installing many fault handlers, most
IDT entries are invalid.  If, for example, your Project 1
code makes an invalid memory reference, a machine check
exception could be raised.  Since you have not installed
a handler for that, there is a good chance
that referencing the nonexistent handler will cause
a "segment not present" exception to be raised.  Since
you have not installed a "segment not present" handler...
</p>

<p>
When a triple fault happens, it is probably a good idea to
use the Simics debugger to determine which exception or interrupt the
processor encountered, figure out why that event took place, and come
up with a plan for dealing with the situation.  One way (but there are
plenty more!) to end up in this situation is to receive a timer interrupt
before your timer driver is complete (what could you do to avoid receiving
timer interrupts?).
</p>

<p>
If you are lucky you may not get all the way to a triple
fault--you may end up in our "purple screen of sadness"
double-fault handler.  But the place to go for advice
is the same...
see the <a href="http://www.cs.cmu.edu/%7E410/doc/triple.html">410 Triple Fault Page</a>.
The meaning of each fault condition is described in
Chapter 5 of
<a href="http://www.cs.cmu.edu/%7E410/doc/intel-sys.pdf">intel-sys.pdf</a>.
</p>

<a name="dualimage"><h3>Grading Makefile and Dual Images</h3></a>

Your code should (already) be structured so that the <tt>kernel_main()</tt>
function in your game.c file, which implements your game,
links with the console API, the keyboard API, and the timer device
driver,
which are implemented by code contained in the external modules (.o files) specified
as $KERNEL_OBJS in your config.mk.
Don't forget to provide the callback function required by the timer API.
<p>

The 410test program provides a different <tt>kernel_main()</tt> function
which will link against the same $OBJS list and will call
your console and keyboard API functions.  Before it does
that, however, it will call <code>handler_install()</code>
so you can set up your interrupt handlers and initialize
global variables your drivers might need.</p><p>
</p><p>


<a name="handin"></a></p><h3><a name="handin">Hand-in Instructions</a></h3>

You will be required to hand in all your .c, .S, .h, and any other
files necessary to run your code.  Minimally this will include the
code for your console driver, timer driver, keyboard driver, and
your game.  Don't forget your config.mk file!
When we run your code, it should display the behavior
described in the <a href="#tying">Tying It All Together</a> section
above.
<p>

See <a href="http://www.cs.cmu.edu/%7E410/p1/handinP1.html">http://www.cs.cmu.edu/~410/p1/handinP1.html</a>
for details.
</p><p>

<a name="starting"></a></p><h3><a name="starting">Where do I start???</a></h3>

<p>Up to you!  But here are some suggestions.</p>

<ol>
<li>You'll probably need to read this assignment document
and the lecture notes more than once.
</li><li>You might want to write down a brief outline in a text
file, specifying which files you intend to organize your
code in and which functions will be written in each.
If you don't want to outline each function, you might
want to write down, for each function, a list of issues
you don't know how to solve.
</li><li>Set yourself an initial goal, such as displaying
your name in the middle of the screen in some approximation
of your favorite color.  This will take longer to accomplish
than you think.
</li><li>Don't defer managing the cursor until the last minute,
because figuring that part out often takes more than a minute.
</li></ol>

<a name="licenses"><h3>Software license notice</h3></a>

Some of the library software used in this class is used
under license
(<a href="http://www.cs.cmu.edu/%7E410/licenses.html">more info</a>).<p>

<!-- ========================================= -->
<!-- Content Ends ============================ -->
<!-- ========================================= -->

<!-- End body. -->


</p></td></tr>
<tr><td></td><td></td><td align="center">

<hr>
<p align="CENTER">[Last modified Friday September 09, 2011]</p></td></tr>
</tbody></table>



 
</div></body></html>